---
title: "KIN6520 – Laboratoire I"
subtitle: "Analyse et interprétation d'un test VO₂max"
author: "Votre nom"
date: today
format:
  html:
    toc: true
    toc-depth: 2
    code-fold: true
  typst:
    toc: true
    number-sections: true
    margin:
      x: 2.5cm
      y: 2.5cm
execute:
  echo: false
  warning: false
  message: false
knitr:
  opts_chunk:
    dev: png
    dpi: 150
---

```{r}
#| label: setup
#| include: false

# Chargement des packages nécessaires
library(tidyverse)

# Chargement des données
data_path <- "data.xlsx"
```

# Introduction

*Objectif : Présenter brièvement l'objectif du laboratoire et le rôle du test VO₂max dans l'évaluation de l'endurance aérobie. (~0.5 page)*

<!--
VOTRE TEXTE ICI

Éléments à couvrir :
- Qu'est-ce que le VO₂max et pourquoi est-il mesuré?
- Objectif spécifique de ce laboratoire
- Structure du rapport
-->

---

# Méthodologie analytique

*Objectif : Décrire et justifier vos choix analytiques. (~1.5 pages)*

::: {.callout-note}
## Critère de la grille (3 pts)
**Choix méthodologiques et justification** : Méthodes clairement décrites, justification physiologique cohérente, discussion de l'impact des choix analytiques.
:::

## Données utilisées

Décrivez les données fournies et les variables retenues pour l'analyse.

```{r}
#| label: description-donnees
#| include = false

# NOTE : le fichier fourni contient généralement :
# - une feuille "Data" (séries temporelles + métadonnées/units au début)
# - une feuille "Results" (résumés exportés par le logiciel)

raw_data <- readxl::read_excel(data_path, sheet = "Data")
raw_results <- readxl::read_excel(data_path, sheet = "Results")

# Aperçu des données (structure, types, colonnes disponibles)
glimpse(raw_data)
glimpse(raw_results)

```

<!--
Décrivez ici :
- Source et nature des données
- Variables analysées et leurs unités
- Nombre d'observations et durée du test
-->

## Traitement des données

Justifiez vos choix de visualisation et de préparation des données.

```{r}
#| label: nettoyage-donnees

# Le fichier "Data" contient souvent 3 premières lignes non analytiques :
# 1) noms de colonnes, 2) unités, 3) champs vides. Les données commencent ensuite.
# Plusieurs colonnes sont importées comme texte : on convertit en numérique au besoin.

parse_num <- function(x) readr::parse_number(as.character(x), locale = readr::locale(decimal_mark = "."))
excel_day_to_sec <- function(x) as.numeric(x) * 86400
safe_max <- function(x) {
  m <- suppressWarnings(max(x, na.rm = TRUE))
  if (is.infinite(m)) NA_real_ else m
}

raw_data <- readxl::read_excel(data_path, sheet = "Data")

meta_raw <- readxl::read_excel(data_path, sheet = "Data", col_names = FALSE) %>%
  slice(1:60)

meta_kv <- tibble(
  key = c(meta_raw[[1]], meta_raw[[4]], meta_raw[[7]]),
  value = c(meta_raw[[2]], meta_raw[[5]], meta_raw[[8]])
) %>%
  filter(!is.na(key), !is.na(value)) %>%
  mutate(
    key = stringr::str_squish(as.character(key)),
    value = as.character(value)
  ) %>%
  distinct()

get_meta <- function(key) {
  value <- meta_kv %>% filter(.data$key == .env$key) %>% slice(1) %>% pull(value)
  if (length(value) == 0) NA_character_ else value
}

participant <- tibble(
  last_name = get_meta("Last Name"),
  first_name = get_meta("First Name"),
  sex = get_meta("Gender"),
  age = suppressWarnings(parse_num(get_meta("Age"))),
  height_cm = suppressWarnings(parse_num(get_meta("Height (cm)"))),
  weight_kg = suppressWarnings(parse_num(get_meta("Weight (kg)"))),
  hr_max_pred_software = suppressWarnings(parse_num(get_meta("HR Max")))
)

knitr::kable(participant)

data_ts <- raw_data %>%
  slice(-(1:3)) %>%
  select(where(~ !all(is.na(.)))) %>%
  mutate(
    Phase = toupper(as.character(Phase)),
    across(
      .cols = -Phase,
      .fns = ~ suppressWarnings(parse_num(.x))
    )
  ) %>%
  mutate(
    t_sec = excel_day_to_sec(t),
    phase_time_sec = excel_day_to_sec(`Phase time`)
  ) %>%
  arrange(t_sec) %>%
  mutate(
    speed_kmh = Speed,
    grade_pct = Grade,
    stage_id = cumsum(
      (Phase != lag(Phase, default = first(Phase))) |
        (speed_kmh != lag(speed_kmh, default = first(speed_kmh))) |
        (grade_pct != lag(grade_pct, default = first(grade_pct)))
    )
  )

# Qualité de la série temporelle : pas d’échantillonnage, valeurs manquantes, etc.
dt_sec <- median(diff(data_ts$t_sec), na.rm = TRUE)
summary_dt <- tibble(
  dt_sec = dt_sec,
  n = nrow(data_ts),
  prop_na_vo2 = mean(is.na(data_ts$VO2))
)
knitr::kable(summary_dt, digits = 3)

# Lissage (utile pour les figures et l'estimation de VO₂peak)
rolling_mean_right <- function(x, k) {
  as.numeric(stats::filter(x, rep(1 / k, k), sides = 1))
}

k_30s <- max(1, round(30 / dt_sec))
k_60s <- max(1, round(60 / dt_sec))

data_ts <- data_ts %>%
  mutate(
    VO2_roll30 = rolling_mean_right(VO2, k_30s),
    VO2kg_roll30 = rolling_mean_right(`VO2/Kg`, k_30s),
    VO2_roll60 = rolling_mean_right(VO2, k_60s),
    VO2kg_roll60 = rolling_mean_right(`VO2/Kg`, k_60s),
    HR_roll30 = rolling_mean_right(HR, k_30s),
    RQ_roll30 = rolling_mean_right(RQ, k_30s),
    VE_roll30 = rolling_mean_right(VE, k_30s)
  )

```

```{r}
#| label: extraire-results-logiciel

# Extraire quelques valeurs "Max" du tableau Results (utile comme contrôle croisé).
# Le format contient des en-têtes répétés : on le lit sans noms de colonnes.

results_raw <- readxl::read_excel(data_path, sheet = "Results", col_names = FALSE)

results_max <- results_raw %>%
  filter(.data$...1 %in% c("VO2", "VO2/Kg", "RQ", "METS", "Speed", "Grade", "t")) %>%
  transmute(
    parameter = as.character(.data$...1),
    unit = as.character(.data$...2),
    max = suppressWarnings(parse_num(.data$...8)),
    norm = as.character(.data$...9),
    class = as.character(.data$...10)
  )

knitr::kable(results_max, digits = 2)

```

```{r}
#| label: visualisation-vo2-temps
#| fig-cap: "Évolution du VO₂ au cours du test incrémental"

stage_starts <- data_ts %>%
  group_by(stage_id, Phase, speed_kmh, grade_pct) %>%
  summarise(t_sec = min(t_sec, na.rm = TRUE), .groups = "drop") %>%
  arrange(t_sec) %>%
  mutate(t_min = t_sec / 60)

vo2_peak_row <- data_ts %>%
  filter(!is.na(VO2_roll30)) %>%
  slice_max(VO2_roll30, n = 1, with_ties = FALSE) %>%
  mutate(t_min = t_sec / 60)

stage_mid <- data_ts %>%
  filter(Phase == "EXERCISE") %>%
  group_by(stage_id, speed_kmh, grade_pct) %>%
  summarise(
    t_min = (min(t_sec, na.rm = TRUE) + max(t_sec, na.rm = TRUE)) / 2 / 60,
    .groups = "drop"
  ) %>%
  mutate(
    label = ifelse(is.na(grade_pct) | grade_pct == 0, paste0(speed_kmh, " km/h"), paste0(speed_kmh, " km/h, ", grade_pct, "%"))
  )

label_y <- safe_max(data_ts$VO2_roll30) * 1.02

ggplot(data_ts, aes(x = t_sec / 60)) +
  geom_vline(
    data = stage_starts %>% filter(Phase == "EXERCISE"),
    aes(xintercept = t_min),
    color = "grey75",
    linewidth = 0.3
  ) +
  geom_text(
    data = stage_mid,
    aes(x = t_min, label = label),
    inherit.aes = FALSE,
    y = label_y,
    size = 3,
    color = "grey30",
    vjust = 0
  ) +
  geom_line(aes(y = VO2), linewidth = 0.35, alpha = 0.5, color = "#2C7FB8") +
  geom_line(aes(y = VO2_roll30), linewidth = 0.7, color = "#D95F0E") +
  geom_point(
    data = vo2_peak_row,
    aes(y = VO2_roll30),
    color = "#D95F0E",
    size = 2
  ) +
  geom_label(
    data = vo2_peak_row,
    aes(
      y = VO2_roll30,
      label = paste0("VO₂peak(30s) = ", round(VO2_roll30), " mL/min")
    ),
    hjust = 0,
    nudge_x = 0.2,
    size = 3
  ) +
  labs(
    x = "Temps (min)",
    y = "VO₂ (mL/min)",
    caption = paste0(
      "Bleu = brut; orange = moyenne mobile ~30 s (k=",
      k_30s,
      "). Lignes verticales = changements de paliers (EXERCISE)."
    )
  ) +
  theme_minimal(base_size = 11)

```

```{r}
#| label: visualisation-vo2-puissance
#| fig-cap: "Relation entre le VO₂ et la charge externe (ex. vitesse sur tapis roulant)"

# Sur tapis roulant, la « charge » est souvent définie par la vitesse (et la pente).
# Une relation VO₂–vitesse (à pente donnée) permet de vérifier la cohérence globale.

ggplot(
  data_ts %>% filter(Phase == "EXERCISE"),
  aes(x = speed_kmh, y = VO2_roll30)
) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = TRUE, linewidth = 0.8) +
  labs(
    x = "Vitesse (km/h)",
    y = "VO₂ (mL/min) – lissé ~30 s",
    caption = "Une forte dispersion, ou une relation non monotone, suggère des artefacts ou une cinétique incomplète."
  ) +
  theme_minimal(base_size = 11)

```

<!--
Justifiez ici :
- Pourquoi avez-vous choisi ces visualisations?
- Qu'observez-vous en termes de bruit vs signal?
- Y a-t-il des artefacts ou valeurs aberrantes?
-->

## Estimation du VO₂max {#sec-estimation}

Décrivez les méthodes utilisées pour estimer le VO₂max et justifiez vos choix.

```{r}
#| label: methode-pic

# Méthode 1 : Pic brut
vo2_peak_raw_ml_min <- max(data_ts$VO2, na.rm = TRUE)
vo2_peak_raw_ml_kg_min <- max(data_ts$`VO2/Kg`, na.rm = TRUE)

```

```{r}
#| label: methode-moyenne-mobile

# Méthode 2 : Moyenne mobile
# Idée ACSM (et pratique de labo) : utiliser un VO₂ "peak" via moyenne mobile (p.ex. 30–60 s),
# car le bruit respiratoire peut gonfler le pic instantané.

vo2_peak_30s_ml_min <- max(data_ts$VO2_roll30, na.rm = TRUE)
vo2_peak_60s_ml_min <- max(data_ts$VO2_roll60, na.rm = TRUE)

vo2_estimates <- tibble(
  methode = c("Pic brut", paste0("Moyenne mobile ~30 s (k=", k_30s, ")"), paste0("Moyenne mobile ~60 s (k=", k_60s, ")")),
  vo2_ml_min = c(vo2_peak_raw_ml_min, vo2_peak_30s_ml_min, vo2_peak_60s_ml_min)
)
knitr::kable(vo2_estimates, digits = 1)

```

<!--
Expliquez ici :
- Pourquoi avez-vous choisi ces méthodes spécifiques?
- Quelle fenêtre de lissage avez-vous utilisée et pourquoi?
- Quels autres paramètres avez-vous considérés?
-->

---

# Résultats

*Objectif : Présenter les graphiques et valeurs de manière claire et factuelle. Pas d'interprétation approfondie ici. (~2 pages)*

::: {.callout-note}
## Critère de la grille (3 pts)
**Analyse des données physiologiques** : Visualisation claire et pertinente, identification correcte des phases, distinction signal/bruit/artefacts.
:::

## Visualisation des données

```{r}
#| label: figure-principale
#| fig-cap: "Comparaison des données brutes et lissées du VO₂"

plot_vo2 <- data_ts %>%
  mutate(t_min = t_sec / 60) %>%
  select(t_min, VO2, VO2_roll30, VO2_roll60) %>%
  pivot_longer(
    cols = c(VO2, VO2_roll30, VO2_roll60),
    names_to = "serie",
    values_to = "vo2"
  ) %>%
  mutate(
    serie = recode(
      serie,
      VO2 = "Brut",
      VO2_roll30 = "Lissé ~30 s",
      VO2_roll60 = "Lissé ~60 s"
    )
  )

ggplot(plot_vo2, aes(x = t_min, y = vo2, color = serie)) +
  geom_line(linewidth = 0.6, alpha = 0.9) +
  scale_color_manual(values = c("Brut" = "#2C7FB8", "Lissé ~30 s" = "#D95F0E", "Lissé ~60 s" = "#31A354")) +
  labs(x = "Temps (min)", y = "VO₂ (mL/min)", color = NULL) +
  theme_minimal(base_size = 11)

```

```{r}
#| label: figure-vo2-hr-rer-ve-temps
#| fig-cap: "VO₂, FC, RER et VE au cours du test (annotations des paliers et points max)"

stage_starts <- data_ts %>%
  group_by(stage_id, Phase, speed_kmh, grade_pct) %>%
  summarise(t_sec = min(t_sec, na.rm = TRUE), .groups = "drop") %>%
  arrange(t_sec) %>%
  mutate(t_min = t_sec / 60)

time_long <- data_ts %>%
  mutate(t_min = t_sec / 60)

time_long <- bind_rows(
  time_long %>% transmute(t_min, Phase, metric = "VO₂ (mL/min)", value = VO2, value_smooth = VO2_roll30),
  time_long %>% transmute(t_min, Phase, metric = "FC (bpm)", value = HR, value_smooth = HR_roll30),
  time_long %>% transmute(t_min, Phase, metric = "RER (RQ)", value = RQ, value_smooth = RQ_roll30),
  time_long %>% transmute(t_min, Phase, metric = "VE (L/min)", value = VE, value_smooth = VE_roll30)
)

peaks <- bind_rows(
  data_ts %>% filter(!is.na(VO2_roll30)) %>% slice_max(VO2_roll30, n = 1, with_ties = FALSE) %>% transmute(metric = "VO₂ (mL/min)", t_min = t_sec / 60, value = VO2_roll30, label = "VO₂peak"),
  data_ts %>% filter(!is.na(HR)) %>% slice_max(HR, n = 1, with_ties = FALSE) %>% transmute(metric = "FC (bpm)", t_min = t_sec / 60, value = HR, label = "FCpeak"),
  data_ts %>% filter(!is.na(RQ)) %>% slice_max(RQ, n = 1, with_ties = FALSE) %>% transmute(metric = "RER (RQ)", t_min = t_sec / 60, value = RQ, label = "RERpeak"),
  data_ts %>% filter(!is.na(VE)) %>% slice_max(VE, n = 1, with_ties = FALSE) %>% transmute(metric = "VE (L/min)", t_min = t_sec / 60, value = VE, label = "VEpeak")
)

ggplot(time_long, aes(x = t_min)) +
  geom_vline(
    data = stage_starts %>% filter(Phase == "EXERCISE"),
    aes(xintercept = t_min),
    color = "grey75",
    linewidth = 0.3
  ) +
  geom_line(aes(y = value), linewidth = 0.35, alpha = 0.55, color = "#2C7FB8") +
  geom_line(aes(y = value_smooth), linewidth = 0.65, alpha = 0.9, color = "#D95F0E") +
  geom_point(data = peaks, aes(y = value), size = 2, color = "black") +
  geom_text(
    data = peaks,
    aes(y = value, label = label),
    nudge_x = 0.2,
    hjust = 0,
    size = 3
  ) +
  facet_wrap(~metric, ncol = 1, scales = "free_y") +
  labs(
    x = "Temps (min)",
    y = NULL,
    caption = "Bleu = brut; orange = moyenne mobile ~30 s; lignes verticales = changements de paliers (EXERCISE)."
  ) +
  theme_minimal(base_size = 11)

```

```{r}
#| label: figure-vs-pct-vo2max
#| fig-cap: "FC, RER et VE en fonction du %VO₂max (EXERCISE)"

vo2_ref <- safe_max(data_ts$VO2_roll30)
if (is.na(vo2_ref)) {
  stop("Impossible de calculer %VO₂max : VO2_roll30 est manquant (vérifier le nettoyage/la conversion numérique).")
}

pct_long <- data_ts %>%
  filter(Phase == "EXERCISE") %>%
  mutate(
    pct_vo2max = 100 * VO2_roll30 / vo2_ref,
    pct_vo2max = pmin(pmax(pct_vo2max, 0), 200)
  ) %>%
  select(pct_vo2max, HR, RQ, VE) %>%
  pivot_longer(cols = c(HR, RQ, VE), names_to = "metric", values_to = "value") %>%
  mutate(
    metric = recode(metric, HR = "FC (bpm)", RQ = "RER (RQ)", VE = "VE (L/min)")
  )

ggplot(pct_long, aes(x = pct_vo2max, y = value)) +
  geom_point(alpha = 0.25, size = 1) +
  geom_smooth(method = "loess", se = TRUE, linewidth = 0.9) +
  facet_wrap(~metric, ncol = 1, scales = "free_y") +
  scale_x_continuous(limits = c(0, 110), breaks = seq(0, 110, 10)) +
  labs(x = "%VO₂max (réf. = VO₂peak lissé ~30 s)", y = NULL) +
  theme_minimal(base_size = 11)

```

## Critères de maximalité (ACSM) – Description factuelle

```{r}
#| label: criteres-maximalite

# Exemples de critères couramment utilisés pour juger si un effort maximal a été atteint :
# - RER (RQ) élevé (souvent ≥ 1.10; parfois ≥ 1.05 selon contexte)
# - FC proche de la FCmax prédite (souvent ±10 bpm)
# - Plateau du VO₂ (ΔVO₂ faible malgré augmentation de charge)
# - (Si mesuré) lactate élevé, RPE/Borg élevé

age <- participant$age[[1]]
sex <- participant$sex[[1]]
weight_kg <- participant$weight_kg[[1]]
hr_max_pred_220 <- 220 - age
hr_max_ref <- dplyr::coalesce(participant$hr_max_pred_software[[1]], hr_max_pred_220)

rer_threshold <- 1.10
hr_within_bpm <- 10
plateau_threshold_ml_min <- 150
plateau_threshold_ml_kg_min <- 2.1

rer_peak <- max(data_ts$RQ, na.rm = TRUE)
hr_peak <- max(data_ts$HR, na.rm = TRUE)

stage_summary <- data_ts %>%
  group_by(stage_id, Phase, speed_kmh, grade_pct) %>%
  summarise(
    n = n(),
    duration_sec = max(t_sec, na.rm = TRUE) - min(t_sec, na.rm = TRUE),
    vo2_ml_min_mean = mean(VO2, na.rm = TRUE),
    vo2_ml_min_tail30 = mean(tail(VO2, k_30s), na.rm = TRUE),
    vo2kg_tail30 = mean(tail(`VO2/Kg`, k_30s), na.rm = TRUE),
    rer_tail30 = mean(tail(RQ, k_30s), na.rm = TRUE),
    hr_tail30 = mean(tail(HR, k_30s), na.rm = TRUE),
    .groups = "drop"
  )

exercise_stages <- stage_summary %>% filter(Phase == "EXERCISE")
last_two <- exercise_stages %>% slice_tail(n = 2)

delta_vo2_last_two <- if (nrow(last_two) == 2) {
  last_two$vo2_ml_min_tail30[2] - last_two$vo2_ml_min_tail30[1]
} else {
  NA_real_
}

delta_vo2_last_two_ml_kg_min <- delta_vo2_last_two / weight_kg

maximality_table <- tibble(
  critere = c(
    "RER (RQ) peak",
    "RER critère atteint?",
    "FC peak",
    "FCmax référence (logiciel ou 220-âge)",
    paste0("FC à ≤ ", hr_within_bpm, " bpm de FCmax?"),
    "ΔVO₂ (fin des 2 derniers stades) [mL/min]",
    paste0("Plateau ≤ ", plateau_threshold_ml_min, " mL/min?"),
    "ΔVO₂ (fin des 2 derniers stades) [mL/kg/min]",
    paste0("Plateau ≤ ", plateau_threshold_ml_kg_min, " mL/kg/min?")
  ),
  valeur = c(
    rer_peak,
    rer_peak >= rer_threshold,
    hr_peak,
    hr_max_ref,
    abs(hr_peak - hr_max_ref) <= hr_within_bpm,
    delta_vo2_last_two,
    ifelse(is.na(delta_vo2_last_two), NA, abs(delta_vo2_last_two) <= plateau_threshold_ml_min),
    delta_vo2_last_two_ml_kg_min,
    ifelse(is.na(delta_vo2_last_two_ml_kg_min), NA, abs(delta_vo2_last_two_ml_kg_min) <= plateau_threshold_ml_kg_min)
  ),
  commentaire = c(
    NA,
    paste0("Seuil indicatif = ", rer_threshold, "."),
    NA,
    "Si la FCmax du logiciel (meta) est disponible, elle est priorisée.",
    paste0("Seuil indicatif = ", hr_within_bpm, " bpm."),
    "Approche stade→stade; à interpréter selon le protocole (paliers vs rampe).",
    NA,
    "Conversion via masse corporelle (meta).",
    NA
  )
)
knitr::kable(maximality_table, digits = 2)

```

## Valeurs obtenues

```{r}
#| label: tableau-resultats

vo2_peak_raw_ml_min <- safe_max(data_ts$VO2)
vo2_peak_raw_ml_kg_min <- safe_max(data_ts$`VO2/Kg`)

vo2_peak_30s_ml_min <- safe_max(data_ts$VO2_roll30)
vo2_peak_60s_ml_min <- safe_max(data_ts$VO2_roll60)

vo2kg_peak_30s <- safe_max(data_ts$VO2kg_roll30)
vo2kg_peak_60s <- safe_max(data_ts$VO2kg_roll60)

vo2_software <- results_max %>% filter(parameter == "VO2") %>% pull(max) %>% dplyr::first()
vo2kg_software <- results_max %>% filter(parameter == "VO2/Kg") %>% pull(max) %>% dplyr::first()
rq_software <- results_max %>% filter(parameter == "RQ") %>% pull(max) %>% dplyr::first()

tbl_vo2 <- tibble(
  estimate = c(
    "Pic brut (VO₂)",
    "VO₂peak lissé ~30 s",
    "VO₂peak lissé ~60 s",
    "VO₂max logiciel (Results)"
  ),
  vo2_ml_min = c(vo2_peak_raw_ml_min, vo2_peak_30s_ml_min, vo2_peak_60s_ml_min, vo2_software),
  delta_vs_30s_ml_min = vo2_ml_min - vo2_peak_30s_ml_min,
  delta_vs_30s_pct = 100 * delta_vs_30s_ml_min / vo2_peak_30s_ml_min
)

tbl_vo2kg <- tibble(
  estimate = c(
    "Pic brut (VO₂/kg)",
    "VO₂peak/kg lissé ~30 s",
    "VO₂peak/kg lissé ~60 s",
    "VO₂max/kg logiciel (Results)"
  ),
  vo2_ml_kg_min = c(vo2_peak_raw_ml_kg_min, vo2kg_peak_30s, vo2kg_peak_60s, vo2kg_software),
  delta_vs_30s_ml_kg_min = vo2_ml_kg_min - vo2kg_peak_30s,
  delta_vs_30s_pct = 100 * delta_vs_30s_ml_kg_min / vo2kg_peak_30s
)

knitr::kable(tbl_vo2, digits = 2)
knitr::kable(tbl_vo2kg, digits = 2)

if (!is.na(rq_software)) {
  tibble(RQ_max_logiciel = rq_software) %>% knitr::kable(digits = 2)
}

```

## Économie de locomotion (et vérification de l’état stable)

```{r}
#| label: economie-steady-state

# IMPORTANT : l’économie de locomotion se calcule idéalement à intensité constante (état stable).
# Dans un protocole incrémental avec paliers courts, le VO₂ peut ne pas atteindre l’état stable,
# ce qui biaise l’économie (VO₂ encore en dérive).

# Diagnostic simple (par stade) : pente du VO₂/kg sur la fin du stade + coefficient de variation.
steady_state_check <- data_ts %>%
  filter(Phase == "EXERCISE") %>%
  group_by(stage_id, speed_kmh, grade_pct) %>%
  group_modify(~ {
    df <- .x
    df_tail60 <- tail(df, min(nrow(df), k_60s))
    df_tail30 <- tail(df, min(nrow(df), k_30s))

    slope_vo2kg_per_min <- if (nrow(df_tail60) >= 3) {
      unname(coef(lm(`VO2/Kg` ~ I(t_sec / 60), data = df_tail60))[2])
    } else {
      NA_real_
    }

    cv_vo2kg_tail30 <- sd(df_tail30$`VO2/Kg`, na.rm = TRUE) / mean(df_tail30$`VO2/Kg`, na.rm = TRUE)

    tibble(
      n = nrow(df),
      duration_sec = max(df$t_sec, na.rm = TRUE) - min(df$t_sec, na.rm = TRUE),
      slope_vo2kg_per_min = slope_vo2kg_per_min,
      cv_vo2kg_tail30 = cv_vo2kg_tail30,
      vo2kg_tail30 = mean(df_tail30$`VO2/Kg`, na.rm = TRUE),
      rer_tail30 = mean(df_tail30$RQ, na.rm = TRUE)
    )
  }) %>%
  ungroup() %>%
  mutate(
    # Seuils indicatifs (à discuter/adapter dans le texte)
    steady_state_flag = (abs(slope_vo2kg_per_min) < 0.5) & (cv_vo2kg_tail30 < 0.10)
  )

# Si état stable plausible : calcul d'économie (mL/kg/km) sur la fin du stade
economy_table <- steady_state_check %>%
  mutate(
    ml_kg_km = vo2kg_tail30 * 60 / speed_kmh
  ) %>%
  select(stage_id, speed_kmh, grade_pct, duration_sec, vo2kg_tail30, rer_tail30, slope_vo2kg_per_min, cv_vo2kg_tail30, steady_state_flag, ml_kg_km)

knitr::kable(steady_state_check, digits = 3)
knitr::kable(economy_table, digits = 3)

```

<!--
Observations factuelles à inclure :
- Valeurs de VO₂max obtenues par chaque méthode
- Différence entre les méthodes (en mL/min et en %)
- Description des phases identifiées dans le test
-->

---

# Discussion

*Objectif : Interpréter les résultats de manière critique et nuancée. (~2-3 pages)*

::: {.callout-note}
## Critère de la grille (3 pts)
**Interprétation physiologique** : Interprétation cohérente et nuancée, limites clairement identifiées, positionnement correct du VO₂max par rapport à l'endurance.
:::

## Comparaison des méthodes d'estimation

<!--
Discutez ici :
- Pourquoi les méthodes donnent-elles des valeurs différentes?
- Quel est l'impact du choix de la fenêtre de lissage?
- Quelle méthode préféreriez-vous dans un contexte clinique vs recherche?
-->

## Limites méthodologiques

<!--
Identifiez les sources d'incertitude :
- Variabilité de la mesure respiratoire
- Choix analytiques et leur impact
- Critères de maximalité (RER, FC, plateau?)
- Représentativité d'un test unique
-->

## Qualité générale du test (lignes directrices)

<!--
Idées d'éléments à documenter (guidelines ACSM / bonnes pratiques de labo) :
- Durée d'exercice jusqu'à épuisement (souvent visée ~8–12 min pour un test VO₂max)
- Progression de la charge (paliers vs rampe) et implications sur cinétique/plateau/économie
- Présence d'échauffement, consignes, arrêt du test (raison)
- Indices d'artefacts : dérive de FiO₂/FiCO₂, FeO₂/FeCO₂, SpO₂ anormale, ruptures de signal
- Cohérence physiologique : relation VO₂–vitesse, FC–VO₂, hausse de VE, RER en fin de test
-->

```{r}
#| label: qc-test-quality

# Résumé QC "automatique" : à interpréter et à compléter dans le texte.

exercise_duration_sec_meta <- excel_day_to_sec(suppressWarnings(parse_num(get_meta("Exercise Duration"))))
test_duration_sec_meta <- excel_day_to_sec(suppressWarnings(parse_num(get_meta("Test Duration"))))

exercise_range <- data_ts %>%
  filter(Phase == "EXERCISE") %>%
  summarise(
    t_start = min(t_sec, na.rm = TRUE),
    t_end = max(t_sec, na.rm = TRUE),
    duration_sec = t_end - t_start,
    .groups = "drop"
  )

stage_durations <- data_ts %>%
  filter(Phase == "EXERCISE") %>%
  group_by(stage_id, speed_kmh, grade_pct) %>%
  summarise(
    duration_sec = max(t_sec, na.rm = TRUE) - min(t_sec, na.rm = TRUE),
    .groups = "drop"
  )

qc_summary <- tibble(
  exercise_duration_sec_meta = exercise_duration_sec_meta,
  test_duration_sec_meta = test_duration_sec_meta,
  exercise_duration_sec_ts = exercise_range$duration_sec,
  n_stages_exercise = nrow(stage_durations),
  stage_duration_median_sec = median(stage_durations$duration_sec, na.rm = TRUE),
  stage_duration_min_sec = min(stage_durations$duration_sec, na.rm = TRUE),
  prop_na_vo2 = mean(is.na(data_ts$VO2)),
  prop_na_hr = mean(is.na(data_ts$HR)),
  vo2_peak_ml_min = max(data_ts$VO2, na.rm = TRUE),
  rer_peak = max(data_ts$RQ, na.rm = TRUE),
  hr_peak = max(data_ts$HR, na.rm = TRUE),
  duration_target_8_12min = dplyr::between(exercise_range$duration_sec / 60, 8, 12)
)

knitr::kable(qc_summary, digits = 3)

```

## VO₂max et performance d'endurance {#sec-vo2max-performance}

<!--
Discutez la relation VO₂max-performance :
- Le VO₂max prédit-il directement la performance?
- Quels autres facteurs sont importants (économie, seuils, cinétique)?
- Ouverture vers les laboratoires suivants
-->

---

# Conclusion

*Synthèse concise (~0.5 page)*

<!--
Message clé à retenir :
- Synthèse des principaux résultats
- Ce que ce laboratoire vous a appris sur l'analyse de données physiologiques
- Une phrase résumant le message central
-->

---

# Annexe – Utilisation de l'IA (si applicable)

*Si vous avez utilisé des outils d'IA (ChatGPT, Claude, Copilot, etc.), décrivez-les ici.*

<!--
Éléments à inclure :
- Outils utilisés et à quel moment
- Exemples de prompts utilisés
- Jugement critique : qu'avez-vous accepté/modifié/rejeté?
- Ce que l'IA a apporté et ses limites observées
-->

---

# Références

<!--
Listez vos sources si vous en avez utilisé.
Format suggéré : APA ou Vancouver
-->
